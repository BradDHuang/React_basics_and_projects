
Reduxï¼š
    a predictable state container for JS apps.
    helps you write applications that 
        1. behave consistently, 
        2. run in different environments (client, server, and native), 
        3. easy to test.
        
When to use Redux
    1. Same piece of application state 
       needs to be mapped to multiple container components (share state).
    2. Too many props 
       are being passed through multiple parent-and-child components.
    3. To separate state out of components for a better code structure.
    

3 Principles:

    1. Single source of truth
    
       The state of your whole application is stored in an object tree within 
       a single store.
       // the entire state of the application will be represented by one JS object.

    2. State is read-only 
    
       The only way to change the state is to 
       emit/dispatch an action.
       // an action: a plain JS object describing the change.
       // In order to define the change, the action object usually has a key .type, 
       // which is just a JS string to indicate the change.

    3. Changes are made with pure functions 
    
       To specify how the state tree is transformed by actions, you write 
       pure reducers.
       // Reducer is the function knowing how to return a new state 
       // based on the action it receives.
       
       // to describe the logic of how to change the state you have 
       // to write a function that takes the previous state of the app and the action being dispatched, 
       // then returns the next state of the app. 
       
       // Pure functions are those whose return values 
       // depend only upon the values of their arguments.
        e.g.
        function square(x) {
          return x * x;
        }
        function squareAll(items) {
          return items.map(square);
          // a new array is returned 
          // instead of modifying the items that was passed in.
        }
        // map calls a provided callback function once for each element in an array, 
        // in order, and constructs a new array from the results.
        // review: A callback function is a function passed into another function as an argument, 
        //         which is then invoked inside the outer function to complete some kind of routine or action.


Store:

    binds together the 3 principles of Redux:

        1. Holds the current application state object
        2. Allows you to dispatch actions
        3. When you create it, you need to specify the reducer that tells how state is updated with actions.
    
    has 3 important methods:
        
        1. getState()
           retrieves the current state of the Redux store.
        2. dispatch()
           how we dispatch actions to change the state of the application.
        3. subscribe()
           registers a callback that the redux store will call 
           any time an action has been dispatched 
           so you can update the UI of your application 
           to reflect the current application state.












